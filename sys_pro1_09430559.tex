\documentclass[a4j,11pt]{jarticle}
% ファイル先頭から\begin{document}までの内容（プレアンブル）については，
% 教員からの指示がない限り， { } の中を書き換えるだけでよい．

% ToDo: 提出要領に従って，適切な余白を設定する
\usepackage[top=25truemm,  bottom=30truemm,
            left=25truemm, right=25truemm]{geometry}

% ToDo: 提出要領に従って，適切なタイトル・サブタイトルを設定する
\title{システムプログラミング1 \\
       期末レポート}

% ToDo: 自分自身の氏名と学生番号に書き換える
\author{氏名: 山田　敬汰 (Yamada，Keita) \\
        学生番号: 09430559}

% ToDo: 教員の指示に従って適切に書き換える
\date{出題日: 2019年10月7日 \\   %todo 正しい日付に置き換える
      提出日: 2019年?月??日 \\
      締切日: 2019年11月18日 \\}  % 注：最後の\\は不要に見えるが必要．

% ToDo: 図を入れる場合，以下の1行を有効にする
%\usepackage{graphicx}

\begin{document}
\maketitle

% 目次つきの表紙ページにする場合はコメントを外す
%{\footnotesize \tableofcontents \newpage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{概要}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

本演習では，C言語で書かれたプログラムを機械語に変換する際に必要不可欠となるアセンブラについて，
いくつかの演習課題を解くことを通じて学びを深めた．具体的には，入出力機能の実装やアセンブリ言語内に登場する用語の解説，
そして，C言語で記述されているプログラムの再現（関数の実装，素数を表示するプログラム及びその保存方法の改造），を行った．
以下に，今回の授業内で実践した5つの演習課題についての詳しい内容を記述する．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{課題1-1}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{課題内容}
教科書A.8節 「入力と出力」に示されている方法と， 
A.9節 最後「システムコール」に示されている方法のそれぞれで "Hello World" を表示せよ．
両者の方式を比較し考察せよ．

\subsection{作成したプログラム（システムコール無し）}

\begin{verbatim}
      1	        .data
      2	        .align 2
      3	msg:
      4	        .asciiz "Hello World"
      5	
      6	        .text
      7	        .align 2      
      8	main:
      9	        
     10	        la      $a1, msg
     11	        
     12	        .text
     13	        .align 2  
     14	putc:
     15	        lb      $a0, 0($a1)             
     16	        lw      $t0, 0xffff0008         # $t0 = *(0xffff0008)
     17	        li      $t1, 1                  # $t1 = 1
     18	        and     $t0, $t0, $t1           # $t0 &= $t1
     19	        beqz    $t0, putc               # if ($t0 == 0) goto putc
     20	        sw      $a0, 0xffff000c         # *(0xffff000c) = $a0
     21	        addi    $a1, $a1, 1
     22	        bnez    $a0, putc
     23	        j       $ra                     # return
 
\end{verbatim}

\subsection{プログラムの解説}
1-4行目では，出力する文字列をあらかじめメモリ上に展開している．

10行目では，先ほどメモリ上に展開した文字列の先頭アドレスをレジスタ$\$a1$に読み込む．

15行目では，$\$a0$に，次に表示する文字のアドレスとして$\$a1$の値を格納する．

16-18行目では入出力機器の状態を取得し，入出力が可能かどうかを判定している．（最下位ビットの値とのAND演算を行う）

19行目では，入出力機器が使用可能な状態でない場合に，$putc$ラベルまで戻る様にしている．（入出力可能になるまで何度も判定を行っている）

20行目では，入出力機器の出力用のアドレスを指定し$\$a0$の値を出力する．

21-23行目では，$\$a1$の持つアドレスを一つずらし，次の文字のアドレスを格納した後，
$\$a0$の値が$0$でなければ（$.asciiz$を使っているので，文字列の末尾のアドレス内には$0$が格納されている）$putc$ラベルに戻る．

\subsection{作成したプログラム（システムコール有り）}

\begin{verbatim}
      1          .data
      2          .align 2
      3  msg:
      4          .asciiz "Hello World"
      5
      6          .text
      7          .align 2
      8  main:
      9          la      $a0, msg
     10          li      $v0, 4
     11          syscall
     12          j       $ra
     13          
\end{verbatim}

\subsection{プログラムの解説}
1-8行目についてはシステムコール無しの場合と違いはないので，説明を省略する．

9-10行目ではシステムコールを呼び出すための下準備を行っている．
具体的には，システムコールに与える引数である$\$a0$に文字列の先頭アドレスを与え，
どのシステムコールを呼ぶかを制御するレジスタ$\$v0$に，「文字列を出力する」ことを意味する$4$を格納する

11行目では実際にシステムコールを呼び出し，先ほど設定した$\$a0$と$\$v0$の値を見て，「$\$a0$を先頭アドレスとした文字列を出力する」
という動作をOSが行う．

この時，入出力機器へのアクセスは全てOSを介して行っているので，プログラム側から直接入出力機器にアクセスすることはない．

\subsection{考察}

両者を比較した時に，システムコールを利用しないプログラムでは，入出力処理を行う際にアドレスを固定値で指定しているのに対し，
システムコールを利用するプログラムでは，入出力処理はシステムコールによりOS側に一任されているので
プログラム内で固定値のアドレスが指定されていない，という違いがある．
この違いによって，システムコールを利用する方のプログラムは入出力装置についての情報を持っていなくても動作するので，
入出力機器が変更されてもプログラムを（疎結合になっている）という利点がある．
その他にも，OS側が許可した動作しかできないようになっているので（各種機器とプロセッサ間を仲介し，互いが直接アクセスしないようにしている），
アドレスを直接指定するよりもセキュリティ上のリスクを減らすことができる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{課題1-2}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{課題内容}
アセンブリ言語中で使用する .data， .text および .align とは何か解説せよ．
 下記コード中の 6行目の .data がない場合，どうなるかについて考察せよ．

\begin{verbatim}
       1:         .text
       2:         .align  2
       3: _print_message:
       4:         la      $a0, msg
       5:         li      $v0, 4
       6:         .data
       7:         .align  2
       8: msg:
       9:         .asciiz "Hello!!\n"
      10:         .text
      11:         syscall
      12:         j       $ra
      13: main:
      14:         subu    $sp, $sp, 24
      15:         sw      $ra, 16($sp)
      16:         jal     _print_message
      17:         lw      $ra, 16($sp)
      18:         addu    $sp, $sp, 24
      19:         j       $ra
\end{verbatim}

\subsection{解答}

.data，.text および .align とは「アセンブラ指令」と呼ばれるもので，主にプログラムの実行前に行われる
前処理を制御するものである．つまり，これらの記述は機械語としてメモリに変換される訳ではない．
その中でも，.data と .text はメモリ中のどこに機械語を配置するかを制御している．
具体的には .data はデータをデータセグメントに配置することを指示し，.text はデータをテキストセグメントに配置することを指示している．
何故，データセグメントとテキストセグメントを区別する必要があるのかというと，データセグメントの内容には読み込みと書き込みが両方行われるのに対し，
テキストセグメントの内容は読み込みしか行われない（値が不変）ので，同一プログラムを他のプロセスで実行する時にテキスト部分を共有することができたり，
読み込み専用領域にデータを置くことができる，というメリットがあるからである．

また .align はオプションとして整数$n$を指定し，データが$2^{n}$ずつの領域に確保される様に余白を取るための命令である．
何故余白を取る必要があるのかというと，MIPSは32ビット（4バイト）ずつデータをCPUとやり取りするため，余白を取って（この場合は$n = 2$）データを綺麗に整列させておくことで，
アクセス回数を減らすことが可能となり，システムの効率化に繋がるからである．

最後に，上記のコード中の6行目の .data がない場合にどうなるかというと，？？？？？？？？？

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{課題1-3}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{課題内容}
教科書A.6節 「手続き呼出し規約」に従って，関数 fact を実装せよ．
(以降の課題においては，この規約に全て従うこと) fact をC言語で記述した場合は，以下のようになるであろう．
\begin{verbatim}
      1: main()
      2: {
      3:   print_string("The factorial of 10 is ");
      4:   print_int(fact(10));
      5:   print_string("\n");
      6: }
      7: 
      8: int fact(int n)
      9: {
     10:   if (n < 1)
     11:     return 1;
     12:   else
     13:     return n * fact(n - 1);
     14: }
\end{verbatim}

\subsection{作成したプログラム}
\begin{verbatim}
      1	        .data
      2	        .align 2
      3	msg:
      4	        .asciiz "The factorial of 10 is "
      5	newline:
      6	        .asciiz "\n"
      7	
      8	        .text
      9	        .align 2
     10	main:
     11	        move    $s0, $ra
     12	        li      $s1, 1
     13	        la      $a0, msg
     14	        jal     print_string
     15	        li      $a0, 10
     16	        jal     fact
     17	        move    $a0, $v0
     18	        jal     print_int
     19	        la      $a0, newline
     20	        jal     print_string
     21	        j       $s0
     22	
     23	fact:
     24	        subu  $sp, $sp, 32
     25	        sw    $fp, 16($sp)
     26	        sw    $ra, 20($sp)
     27	
     28	        addu  $fp, $sp, 28
     29	        sw    $a0, 0($fp)
     30	
     31	        bgtz  $a0, Lthen
     32	        j     Lelse 
     33	
     34	Lthen:
     35	        subu  $a0, $a0, 1
     36	        jal   fact
     37	
     38	        lw    $v1, 0($fp)   
     39	        mul   $v0, $v0, $v1
     40	        j     Lreturn
     41	        
     42	Lelse:
     43	        li    $v0, 1
     44	        j     Lreturn
     45	
     46	Lreturn:
     47	        lw    $fp, 16($sp)
     48	        lw    $ra, 20($sp) 
     49	        addiu $sp, $sp, 32
     50	        j     $ra
     51	
     52	print_string:
     53	        li      $v0, 4
     54	        syscall
     55	        j       $ra
     56	
     57	print_int:
     58	        li      $v0, 1
     59	        syscall
     60	        j       $ra
     61	         
\end{verbatim}

\subsection{プログラムの解説}
ここでは$fact$関数内で行われている処理に対応している部分について，処理の流れを追いながら詳細に解説する．

\begin{enumerate}
      \item \label{push_start} $\$sp$の値を減算し，スタックを32バイト分確保した後，そこに$\$fp$と$\$ra$，$\$a0$の値を退避させる．（24-29行目）
      \item $\$a0$の値を確認し，その値が$0$かどうかで処理を分岐する．（31-32行目）
      \item \label{push_b}$\$a0$の値が$0$より大きいので，$Lthen$ラベルの場所にジャンプする．
      \item \label{push_end}$\$a0$の値を一つ減らし，その後$fact$を再帰的に呼び出す（35-36行目）
      \item \ref{push_start} から \ref{push_end} までの処理を$\$a0$の値が$0$になるまで繰り返す．
      \item $\$a0$の値が$0$になった時，\ref{push_b}のタイミングで$Lthen$ラベルでは無く$Lelse$ラベルの場所にジャンプする．
      \item $\$v0$に$1$を格納した後，$Lreturn$ラベルの場所にジャンプする．（43-44行目）
      \item \label{pop_start}直近にスタックに退避させた値（32バイト分）をレジスタに復帰させた後，$\$sp$の値を加算し，使用済みスタック領域の解放を行う．（47-49行目）
      \item \label{pop_b}$\$ra$レジスタに格納されている，\ref{push_end}の$fact$にジャンプする命令の次の命令のアドレスに移動する．（50行目）
      \item スタックに退避しておいた$\$a0$の値を$\$v1$に格納し，$\$v0$の値を自身と$\$v1$の積の値に上書きする．（38-39行目）
      \item \label{pop_end}$Lreturn$ラベルの場所にジャンプする．（40行目）
      \item \ref{pop_start}から\ref{pop_end}までの処理を繰り返す．
      \item 一番最初にスタックに退避させた$\$ra$には一番最初に$fact$を呼び出した時の次の命令のアドレスが格納されているので，
      このプログラムで確保したスタック領域を解放しきった後，\ref{pop_b}のタイミングで17行目の命令に移動し，$fact$の一連の処理が終了する．（計算結果は$\$v0$に格納されている）
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{課題1-4}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{課題内容}
素数を最初から100番目まで求めて表示するMIPSのアセンブリ言語プログラムを作成してテストせよ． 
その際，素数を求めるために下記の2つのルーチンを作成すること．

\begin{itemize}
      \item test\_prime(n)    nが素数なら1，そうでなければ0を返す
      \item main()       整数を順々に素数判定し，100個プリント
\end{itemize}

\subsection{C言語で記述したプログラム例}

\begin{verbatim}
      1: int test_prime(int n)
      2: {
      3:   int i;
      4:   for (i = 2; i < n; i++){
      5:     if (n % i == 0)
      6:       return 0;
      7:   }
      8:   return 1;
      9: }
     10: 
     11: int main()
     12: {
     13:   int match = 0, n = 2;
     14:   while (match < 100){
     15:     if (test_prime(n) == 1){
     16:       print_int(n);
     17:       print_string(" ");
     18:       match++;
     19:     }
     20:     n++;
     21:   }
     22:   print_string("\n");
     23: }
\end{verbatim}

\subsection{作成したプログラム}

\begin{verbatim}
      1	    .data
      2	    .align  2
      3	
      4	newline:
      5	        .asciiz "\n"
      6	space:
      7	        .asciiz " "
      8	
      9	　　.text
     10	　　.align	2
     11	
     12	test_prime:				    # int test_prime(int n = $a0)
     13	
     14		li	$a3,2			    # forのループ数カウンタ
     15	
     16	for:
     17	      slt	$v0,$a3,$a1	        # if !(i < n)
     18	      beq	$v0,$zero,return1	#   return 1
     19	
     20	      div	$a1,$a3			    # $a0 = 
     21		mfhi	$v0			    # $v0 = n % i
     22		beq	$v0,$zero,return0	# if ($v0 == 0) return 0
     23	
     24	      addi	$a3, $a3, 1		# $a3 = $a3 + 0
     25	      j     for
     26	
     27	while:
     28		slt	$v0,$a2,$a0		    # if !(i < n)
     29		beq	$v0,$zero,return1	#   return 1
     30	
     31	      jal   test_prime
     32	      beq   $v0,$s1,match
     33	
     34	      addi	$a1, $a1, 1		# $a1 = $a1 + 1
     35		j	while			    # goto while
     36	
     37	match: 
     38	      move    $s2, $a0
     39	      move    $a0, $a1
     40	      jal     print_int
     41	      la      $a0, space
     42	      jal     print_string
     43	      move    $a0, $s2
     44	
     45	      addi	  $a1, $a1, 1			# $a1 = $a1 + 0
     46	      addi	  $a2, $a2, 1			# $a2 = $a2 + 0
     47	      j       while
     48	
     49	main:
     50	      move    $s0, $ra
     51	      li      $s1, 1
     52	      la      $a0, 100 
     53	      li      $a1, 2      # whileのループ数カウンタ
     54	      li      $a2, 0      # match数
     55	      jal     while
     56	      la      $a0, newline
     57	      jal     print_string
     58	      j	  $s0				# jump to $s0
     59	
     60	
     61	return0:
     62	      li	$v0,0
     63	      j	$ra
     64	
     65	return1:
     66	      li	$v0,1
     67	      j	$ra
     68	
     69	print_string:
     70	      li      $v0, 4
     71	      syscall
     72	      j       $ra
     73	
     74	print_int:
     75	      li      $v0, 1
     76	      syscall
     77	      j       $ra
\end{verbatim}

\subsection{プログラムの解説}
上記のプログラムの内容について，処理の流れを追いながら詳細に解説する．

\begin{enumerate}
      \item 各種変数の初期化を行う．（$\$a0$：表示する素数の上限，$\$a1$：whileループのループ数カウンタ，$\$a2$：見つかった素数の数）（52-54行目）
      \item $while$ラベルジャンプする．（55行目）
      \item \label{begin_while}見つかった素数の数が表示する上限を超えているかどうか確認する．（$\$a2$と$\$a0$を比較している）
      \item $\$a2 < \$a0$なので，ループの中に入り$test\_prime$ラベルにジャンプする．
      \item $\$a1$ が素数かどうかを確かめるために必要な変数 $\$a3$（除数）を初期化する．
      \item $\$a1$ の値が $\$a3$ で割り切れるかを確かめ，割り切れた場合は $\$v0$ に $0$ を格納し，$test\_prime$ラベルの呼び出し元へ帰る．
      \item 割り切れない場合は$\$a3$の値を加算し続けながら割り切れるかどうかを確かめ，割り切れないまま$\$a3$の値が$\$a1$の値までたどり着いた時，
      $\$v0$ に $1$ を格納し，$test\_prime$の呼び出し元へ帰る．（$\$a1$は素数）
      \item $\$v0$の値が$1$ならば（$\$a1$が素数ならば），$match$ラベルにジャンプした後，$\$a1$の値を画面に出力し，$\$a2$の値を加算する．
      \item \label{end_while}$\$a1$の値を加算し，\ref{begin_while}まで戻る．
      \item \ref{begin_while}から\ref{end_while}までを繰り返し，$\$a2$の値が$\$a0$以上になった時，$while$ラベルの呼び出し元へ帰り，プログラムを終了する．
\end{enumerate}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{課題1-5}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{課題内容}

素数を最初から100番目まで求めて表示するMIPSのアセンブリ言語プログラムを作成してテストせよ． 
ただし，配列に実行結果を保存するように main 部分を改造し， 
ユーザの入力によって任意の番目の配列要素を表示可能にせよ．

\subsection{C言語で記述したプログラム例}

\begin{verbatim}
      1: int primes[100];
      2: int main()
      3: {
      4:   int match = 0, n = 2;
      5:   while (match < 100){
      6:     if (test_prime(n) == 1){
      7:       primes[match++] = n;
      8:     }
      9:     n++;
     10:   }
     11:   for (;;){
     12:     print_string("> ");
     13:     print_int(primes[read_int() - 1]);
     14:     print_string("\n");
     15:   }
     16: }
\end{verbatim}

\subsection{作成したプログラム}

\begin{verbatim}
      1	    .data
      2	    .align  2
      3	newline:
      4	        .asciiz "\n"
      5	    .data
      6	    .align  2
      7	input:
      8	        .asciiz "> "
      9	    .data
     10	    .align  2    
     11	primes:
     12	        .space 400
     13	
     14		.text
     15		.align	2
     16	
     17	test_prime:				    
     18		li	$a3, 2			    # forのループ数カウンタ
     19	
     20	for:
     21	    slt	$v0,$a3,$a1	        
     22		beq	$v0,$zero,return1	
     23	
     24	    div	$a1,$a3			    
     25		mfhi	$v0			    
     26		beq	$v0,$zero,return0	
     27	
     28	    addi	$a3, $a3, 1
     29	    j   for
     30	
     31	while:
     32		slt	$v0,$a2,$a0		    
     33		beq	$v0,$zero,return1	
     34	
     35	    move $s3, $ra
     36	    jal test_prime
     37	    move $ra, $s3
     38	    beq $v0,$s1,match
     39	
     40	    addi	$a1, $a1, 1		
     41		j	while			    
     42	
     43	match: 
     44	
     45	    move    $s3, $ra
     46	    move    $a3, $a2
     47	    jal     get_address   
     48	    move    $ra, $s3
     49	    sw      $a1, 0($v0)
     50	    
     51	    addi	$a1, $a1, 1			
     52	    addi	$a2, $a2, 1			
     53	    j       while
     54	
     55	main:
     56	    move    $s0, $ra
     57	    li      $s1, 1
     58	    la		$a0, 100 
     59	    li      $a1, 2          # whileのループ数カウンタ
     60	    li      $a2, 0          # match数
     61	    la      $t1, primes     # 配列の先頭アドレス
     62	    jal     while
     63	    j		find			
     64	    
     65	find:     
     66	    la      $a0, input
     67	    jal     print_string
     68	    jal     read_int
     69	    move    $a3, $v0
     70	    addi    $a3, $a3, -1   # $a3 を一つ減算
     71	    jal		get_address	
     72	    lw		$a0, 0($v0) 
     73	    jal     print_int
     74	    la      $a0, newline
     75	    jal     print_string
     76	    j       find
     77	
     78	get_address:
     79	    addu    $a3, $a3, $a3  # $a0 (match) を倍に
     80	    addu    $a3, $a3, $a3  # $a0 を更に倍に ($a0 = match * 4)
     81	    addu    $a3, $t1, $a3  # $a0 = $t1 + $a0
     82	    move    $v0, $a3
     83	    j		$ra				# jump to $ra
     84	    
     85	return0:
     86		li	$v0,0
     87		j	$ra
     88	
     89	return1:
     90		li	$v0,1
     91		j	$ra
     92	
     93	print_string:
     94	    li      $v0, 4
     95	    syscall
     96	    j       $ra
     97	
     98	print_int:
     99	    li      $v0, 1
    100	    syscall
    101	    j       $ra
    102	
    103	read_int:
    104	    li		$v0, 5
    105	    syscall
    106	    j       $ra 
\end{verbatim}

\subsection{プログラムの解説}
上記のプログラムについて，課題1-4との変更点の部分を中心に解説する．

一つ目の違いとしては，素数を発見した時の処理である．1-4のプログラムでは，
発見したタイミングでその素数を出力するので，その値を保持しておく必要がないのに対して，上記のプログラムでは，
後のユーザー入力に対する処理で使用するため，見つけた素数を全て保持しておく必要がある．
今回のプログラムではメモリ上に値を保持することで

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{感想}
今回の課題を進めていく上での感想としては，アセンブリ言語でプログラムを書こうとすると
簡単な処理でも冗長なソースコードを書かなければならないので，
コンピュータの動作を一歩一歩丁寧に追えるようになっていることを実感するとともに，
改めてC言語のような高級言語やそれをアセンブリ言語に変換してくれるコンパイラのありがたみを感じることができた．

また，アセンブリ言語でプログラムを書いていると，$j$命令や$jal$命令などで，コードを行ったり来たりすることが多々あり，
何も考えずにプログラムを書いていると，処理の流れを追うのが困難になってしまうので，
適切なラベル名の命名やどこに何の処理を書くべきかを考えながらプログラムを実装することが大事だと感じた．
具体例としては，特定のラベル内からし呼び出されないラベルの接頭辞として$L$を追加したり，
if-else の分岐を明確にするために，それぞれの処理の最後に同じラベルへの$j$命令を追加して枝分かれしていることを表す，といった工夫を行った．

\end{document}
