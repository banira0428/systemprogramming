\documentclass[a4j,11pt]{jarticle}
% ファイル先頭から\begin{document}までの内容（プレアンブル）については，
% 教員からの指示がない限り， { } の中を書き換えるだけでよい．

% ToDo: 提出要領に従って，適切な余白を設定する
\usepackage[top=25truemm,  bottom=30truemm,
            left=25truemm, right=25truemm]{geometry}

% ToDo: 提出要領に従って，適切なタイトル・サブタイトルを設定する
\title{システムプログラミング2 \\
       期末レポート}

% ToDo: 自分自身の氏名と学生番号に書き換える
\author{氏名: 山田　敬汰 (Yamada，Keita) \\
        学生番号: 09430559}

% ToDo: 教員の指示に従って適切に書き換える
\date{出題日: 2019年12月9日 \\   %todo 正しい日付に置き換える
      提出日: 2019年??月??日 \\
      締切日: 2020年1月27日 \\}  % 注：最後の\\は不要に見えるが必要．

% ToDo: 図を入れる場合，以下の1行を有効にする
%\usepackage{graphicx}

\begin{document}
\maketitle

% 目次つきの表紙ページにする場合はコメントを外す
%{\footnotesize \tableofcontents \newpage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{概要}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{課題2-1}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{課題内容}
SPIMが提供するシステムコールを C言語から実行できるようにしたい． 教科書A.6節 「手続き呼出し規約」に従って，各種手続きをアセンブラで記述せよ． ファイル名は，{\tt syscalls.s} とすること．

また，記述した {\tt syscalls.s} の関数をC言語から呼び出すことで， ハノイの塔({\tt hanoi.c} とする)を完成させよ．

\subsection{C言語で記述したプログラム例}

\begin{verbatim}
      1	#include <stdio.h>
      2	
      3	void hanoi(int n, int start, int finish, int extra)
      4	{
      5	    if (n != 0)
      6	    {
      7	        hanoi(n - 1, start, extra, finish);
      8	        print_string("Move disk ");
      9	        print_int(n);
     10	        print_string(" from peg ");
     11	        print_int(start);
     12	        print_string(" to peg ");
     13	        print_int(finish);
     14	        print_string(".\n");
     15	        hanoi(n - 1, extra, finish, start);
     16	    }
     17	}
     18	main()
     19	{
     20	    int n;
     21	    print_string("Enter number of disks> ");
     22	    n = read_int();
     23	    hanoi(n, 1, 2, 3);
     24	}     
\end{verbatim}

\subsection{作成したプログラム}
\begin{verbatim}
      1	.text
      2	.align 2
      3	
      4	_print_int:
      5	 subu    $sp,$sp,24
      6	 sw      $ra,20($sp)
      7	
      8	 li      $v0, 1
      9	 syscall
     10	
     11	 lw      $ra,20($sp)
     12	 addu    $sp,$sp,24
     13	 j       $ra 
     14	
     15	_print_string:
     16	 subu    $sp,$sp,24
     17	 sw      $ra,20($sp)
     18	
     19	 li      $v0, 4
     20	 syscall
     21	
     22	 lw      $ra,20($sp)
     23	 addu    $sp,$sp,24
     24	 j       $ra 
     25	
     26	_read_int:
     27	 subu    $sp,$sp,24
     28	 sw      $ra,20($sp)
     29	
     30	 li      $v0, 5
     31	 syscall
     32	
     33	 lw      $ra,20($sp)
     34	 addu    $sp,$sp,24
     35	 j       $ra 
     36	
     37	_read_string:
     38	 subu    $sp,$sp,24
     39	 sw      $ra,20($sp)
     40	
     41	 li      $v0, 8
     42	 syscall
     43	
     44	 lw      $ra,20($sp)
     45	 addu    $sp,$sp,24
     46	 j       $ra
     47	
     48	_exit:
     49	 li      $v0, 10
     50	 syscall
     51	
\end{verbatim}

\subsection{実行結果}

\begin{verbatim}
      Enter number of disks>  4
      Move disk 1 from peg 1 to peg 3.
      Move disk 2 from peg 1 to peg 2.
      Move disk 1 from peg 3 to peg 2.
      Move disk 3 from peg 1 to peg 3.
      Move disk 1 from peg 2 to peg 1.
      Move disk 2 from peg 2 to peg 3.
      Move disk 1 from peg 1 to peg 3.
      Move disk 4 from peg 1 to peg 2.
      Move disk 1 from peg 3 to peg 2.
      Move disk 2 from peg 3 to peg 1.
      Move disk 1 from peg 2 to peg 1.
      Move disk 3 from peg 3 to peg 2.
      Move disk 1 from peg 1 to peg 3.
      Move disk 2 from peg 1 to peg 2.
      Move disk 1 from peg 3 to peg 2.           
\end{verbatim}

\subsection{プログラムの解説}
ここでは{\tt \_print\_int}部分での手続きを例に解説する．
\begin{enumerate}
      \item スタックの領域を$24$バイト確保し，戻りアドレスを格納しておく．戻りアドレスを退避させている理由としては，
      {\tt syscall}内の手続きがOSに一任され，アセンブリのプログラムから分からないようになっているからである．
      （つまり，OSが勝手に$\$ra$レジスタの値を壊している可能性を考慮している．）
      \item $\$v0$レジスタに適切な番号（{\tt \_print\_int}の場合は$1$）を格納し，{\tt syscall}命令を発行する．
      \item スタックに格納しておいた戻りアドレスを$\$ra$レジスタに再び格納し，呼び出し元に帰る．
\end{enumerate}

その他の手続きも$\$v0$レジスタの値を変更することで，同様の手順で実行することができる．（OSによって抽象化されている．）

また，{\tt exit}手続きのみ，スタックに戻りアドレスを格納していない．
その理由としては{\tt syscall}の発行によってプロセスが終了するので，
値を退避させたところで復帰させる方法がないからである．

\subsection{考察}

今回のプログラムでは{\tt syscall}を呼び出す部分のみをアセンブリ言語で記述している．
これは，C言語の中から直接{\tt syscall}命令を発行する方法が存在しないからである．
そして，実行する時にC言語の部分をアセンブリ言語にコンパイルし，{\tt syscalls.s}と共に正しい順序でメモリ上に読み込むことで，
プログラムを実行することができる．ここで，ファイル読み込みを間違えた場合は関数の参照先が未定義となり，プログラムが例外を発生する．

また，手続き呼び出し規約によって「引数はどのレジスタに入っていて，戻り値はこのレジスタに入っている」というのが決められているので，
この規約を守っている限りはC言語とアセンブリ言語との連携を円滑に行うことができる．
言い換えれば，プログラマはコンパイラがどのようにC言語のプログラムを変換するのか（レジスタを決定するルール）を知っていなければアセンブリ言語を書くことができない，ということである．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{課題2-2}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{課題内容}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{課題2-3}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{課題内容}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{課題2-4}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{課題内容}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{課題2-5}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{課題内容}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{感想}

\end{document}
